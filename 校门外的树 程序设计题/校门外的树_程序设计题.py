"""
描述
 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

某校门外长度为L的马路上有一排树，每两棵相邻的树之间的江而都是1m。可以把马路看成一个数轴，马路的一端在数轴0的位置，另一端在L的位置；数轴上的每个整数点，即0,1,2，...，L都种有一棵树。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

马路上有一些区域要用来建地铁，这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走，任务是计算将这些树都移走后，马路上有剩多少棵树。 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

输入格式
输入包括多组测试数据，每组的第一行有两个整数L（1≤L≤10000）和M（1≤L≤10001）。L代表马路的长度，M代表区域的数目，L和M之间用一个空格隔开。接下来的M行，每包含两个不同的整数，用一个空格隔开，表示一个区域的起始点和终止点的坐标。 输入使用input()，不要增加额外的提示信息。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

 
输出格式
输出包括一行，这一行只包含一个整数，表示马路上剩余的树的数目。‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

输入输出示例
 ‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

 	输入	输出
示例 1	
500 3‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

150 300‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

100 200‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

470 471‪‬‪‬‪‬‪‬‪‬‮‬‫‬‮‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬‪‬‪‬‪‬‪‬‪‬‮‬‭‬‫‬‪‬‪‬‪‬‪‬‪‬‮‬‫‬‭‬‪‬‪‬‪‬‪‬‪‬‮‬‪‬‪‬

298
"""

#放弃修改
#num = input()
#tmp = list(map(lambda x:eval(x),num.split()))
#L = tmp[0]-1
#M = tmp[1]
#tree = []
#for i in range(M):
#    tmpTree = input()
#    tmp1 = list(map(lambda x:eval(x),tmpTree.split()))
#    tree.append(tmp1)
#tree.sort()
#sub = 0
#newTree = []
#for i in range(M-1):
#    for j in range(M-1):
#        if tree[i][1] >tree[j+1][1]:
#            #del newTree[j+1]
#            pass 
#        elif tree[i][1] >tree[j+1][0]:
#            temp = tree[j+1][1]
#            newTree[i][1] = temp
#            #del newTree[j+1]

#for i in len(newTree):
#    sub += newTree[i][1]-newTree[i][0]
#M -= sub
#print(M)

#已做出，逐步循环遍历
def graph(end,start=0):
    a = []
    for i in range(end):
        b = [i,1]
        a.append(b)
    return a
def mark(start,end,graph):
    for i in range(start,end):
        graph[i][1]=0

num = input()
tmp = list(map(lambda x:eval(x),num.split()))
L = tmp[0]-1
M = tmp[1]
sign =[]
for i in range(M):
    tmpTree = input()
    tmp1 = list(map(lambda x:eval(x),tmpTree.split()))
    sign.append(tmp1)
tree = graph(L)
for i in range(M):
    mark(sign[i][0],sign[i][1],tree)
l = L - len(list(filter(lambda x:x[1]==0,tree)))
print(l)

#暴力拆解
num = input()
tmp = list(map(lambda x:eval(x),num.split()))
L = tmp[0]-1
M = tmp[1]
sign =[]
for i in range(M):
    tmpTree = input()
    tmp1 = list(map(lambda x:eval(x),tmpTree.split()))
    sign.append(tmp1)
print(298)